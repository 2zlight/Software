   1               		.file	"light_ws2812.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   9               		.text
  10               	.Ltext0:
 111               	ws2812_send_byte:
 112               		.stabd	46,0,0
   1:ws2812/light_ws2812.c **** /*
   2:ws2812/light_ws2812.c **** * light weight WS2812 lib V2.0b
   3:ws2812/light_ws2812.c **** *
   4:ws2812/light_ws2812.c **** * Controls WS2811/WS2812/WS2812B RGB-LEDs
   5:ws2812/light_ws2812.c **** * Author: Tim (cpldcpu@gmail.com)
   6:ws2812/light_ws2812.c **** *
   7:ws2812/light_ws2812.c **** * Jan 18th, 2014  v2.0b Initial Version
   8:ws2812/light_ws2812.c **** * Nov 29th, 2015  v2.3  Added SK6812RGBW support
   9:ws2812/light_ws2812.c **** *
  10:ws2812/light_ws2812.c **** * License: GNU GPL v2 (see License.txt)
  11:ws2812/light_ws2812.c **** */
  12:ws2812/light_ws2812.c **** 
  13:ws2812/light_ws2812.c **** #include "light_ws2812.h"
  14:ws2812/light_ws2812.c **** #include <avr/interrupt.h>
  15:ws2812/light_ws2812.c **** #include <avr/io.h>
  16:ws2812/light_ws2812.c **** #include <util/delay.h>
  17:ws2812/light_ws2812.c ****  
  18:ws2812/light_ws2812.c **** // Setleds for standard RGB 
  19:ws2812/light_ws2812.c **** void inline ws2812_setleds(struct cRGB *ledarray, uint16_t leds)
  20:ws2812/light_ws2812.c **** {
  21:ws2812/light_ws2812.c ****    ws2812_setleds_pin(ledarray,leds, _BV(ws2812_pin));
  22:ws2812/light_ws2812.c **** }
  23:ws2812/light_ws2812.c **** 
  24:ws2812/light_ws2812.c **** void inline ws2812_setleds_pin(struct cRGB *ledarray, uint16_t leds, uint8_t pinmask)
  25:ws2812/light_ws2812.c **** {
  26:ws2812/light_ws2812.c ****   ws2812_sendarray_mask((uint8_t*)ledarray,leds+leds+leds,pinmask);
  27:ws2812/light_ws2812.c ****   _delay_us(50);
  28:ws2812/light_ws2812.c **** }
  29:ws2812/light_ws2812.c **** 
  30:ws2812/light_ws2812.c **** // Setleds for SK6812RGBW
  31:ws2812/light_ws2812.c **** void inline ws2812_setleds_rgbw(struct cRGBW *ledarray, uint16_t leds)
  32:ws2812/light_ws2812.c **** {
  33:ws2812/light_ws2812.c ****   ws2812_sendarray_mask((uint8_t*)ledarray,leds<<2,_BV(ws2812_pin));
  34:ws2812/light_ws2812.c ****   _delay_us(80);
  35:ws2812/light_ws2812.c **** }
  36:ws2812/light_ws2812.c **** 
  37:ws2812/light_ws2812.c **** static void inline ws2812_send_byte(uint8_t curbyte, uint8_t maskhi, uint8_t masklo);
  38:ws2812/light_ws2812.c **** 
  39:ws2812/light_ws2812.c **** void ws2812_setleds_constant(struct cRGB *ledval, uint16_t leds)
  40:ws2812/light_ws2812.c **** {
  41:ws2812/light_ws2812.c ****   uint8_t masklo,maskhi;
  42:ws2812/light_ws2812.c ****   uint8_t sreg_prev;
  43:ws2812/light_ws2812.c **** 
  44:ws2812/light_ws2812.c ****   maskhi = _BV(ws2812_pin);
  45:ws2812/light_ws2812.c ****   ws2812_DDRREG |= maskhi; // Enable output
  46:ws2812/light_ws2812.c **** 
  47:ws2812/light_ws2812.c ****   masklo	=~maskhi&ws2812_PORTREG;
  48:ws2812/light_ws2812.c ****   maskhi |=        ws2812_PORTREG;
  49:ws2812/light_ws2812.c **** 
  50:ws2812/light_ws2812.c ****   sreg_prev=SREG;
  51:ws2812/light_ws2812.c ****   cli();
  52:ws2812/light_ws2812.c **** 
  53:ws2812/light_ws2812.c ****   while (leds--) {
  54:ws2812/light_ws2812.c ****     uint8_t i;
  55:ws2812/light_ws2812.c ****     for (i = 0; i < 3; i++) {
  56:ws2812/light_ws2812.c ****       ws2812_send_byte(((uint8_t *)ledval)[i], maskhi, masklo);
  57:ws2812/light_ws2812.c ****     }
  58:ws2812/light_ws2812.c ****   }
  59:ws2812/light_ws2812.c ****   SREG=sreg_prev;
  60:ws2812/light_ws2812.c ****   _delay_us(50);
  61:ws2812/light_ws2812.c **** }
  62:ws2812/light_ws2812.c **** 
  63:ws2812/light_ws2812.c **** void ws2812_setleds_constant_rgbw(struct cRGBW *ledval, uint16_t leds)
  64:ws2812/light_ws2812.c **** {
  65:ws2812/light_ws2812.c ****   uint8_t masklo,maskhi;
  66:ws2812/light_ws2812.c ****   uint8_t sreg_prev;
  67:ws2812/light_ws2812.c **** 
  68:ws2812/light_ws2812.c ****   maskhi = _BV(ws2812_pin);
  69:ws2812/light_ws2812.c ****   ws2812_DDRREG |= maskhi; // Enable output
  70:ws2812/light_ws2812.c **** 
  71:ws2812/light_ws2812.c ****   masklo	=~maskhi&ws2812_PORTREG;
  72:ws2812/light_ws2812.c ****   maskhi |=        ws2812_PORTREG;
  73:ws2812/light_ws2812.c **** 
  74:ws2812/light_ws2812.c ****   sreg_prev=SREG;
  75:ws2812/light_ws2812.c ****   cli();
  76:ws2812/light_ws2812.c **** 
  77:ws2812/light_ws2812.c ****   while (leds--) {
  78:ws2812/light_ws2812.c ****     uint8_t i;
  79:ws2812/light_ws2812.c ****     for (i = 0; i < 4; i++) {
  80:ws2812/light_ws2812.c ****       ws2812_send_byte(((uint8_t *)ledval)[i], maskhi, masklo);
  81:ws2812/light_ws2812.c ****     }
  82:ws2812/light_ws2812.c ****   }
  83:ws2812/light_ws2812.c ****   SREG=sreg_prev;
  84:ws2812/light_ws2812.c ****   _delay_us(80);
  85:ws2812/light_ws2812.c **** }
  86:ws2812/light_ws2812.c **** 
  87:ws2812/light_ws2812.c **** void ws2812_sendarray(uint8_t *data,uint16_t datlen)
  88:ws2812/light_ws2812.c **** {
  89:ws2812/light_ws2812.c ****   ws2812_sendarray_mask(data,datlen,_BV(ws2812_pin));
  90:ws2812/light_ws2812.c **** }
  91:ws2812/light_ws2812.c **** 
  92:ws2812/light_ws2812.c **** /*
  93:ws2812/light_ws2812.c ****   This routine writes an array of bytes with RGB values to the Dataout pin
  94:ws2812/light_ws2812.c ****   using the fast 800kHz clockless WS2811/2812 protocol.
  95:ws2812/light_ws2812.c **** */
  96:ws2812/light_ws2812.c **** 
  97:ws2812/light_ws2812.c **** // w1 - nops between rising edge and falling edge - low
  98:ws2812/light_ws2812.c **** #define w1 1
  99:ws2812/light_ws2812.c **** // w2   nops between fe low and fe high
 100:ws2812/light_ws2812.c **** #define w2 5 
 101:ws2812/light_ws2812.c **** // w3   nops to complete loop
 102:ws2812/light_ws2812.c **** #define w3 0
 103:ws2812/light_ws2812.c **** 
 104:ws2812/light_ws2812.c **** #if w1>0
 105:ws2812/light_ws2812.c ****   #define w1_nops w1
 106:ws2812/light_ws2812.c **** #else
 107:ws2812/light_ws2812.c ****   #define w1_nops  0
 108:ws2812/light_ws2812.c **** #endif
 109:ws2812/light_ws2812.c **** 
 110:ws2812/light_ws2812.c **** #if w2>0
 111:ws2812/light_ws2812.c **** #define w2_nops w2
 112:ws2812/light_ws2812.c **** #else
 113:ws2812/light_ws2812.c **** #define w2_nops  0
 114:ws2812/light_ws2812.c **** #endif
 115:ws2812/light_ws2812.c **** 
 116:ws2812/light_ws2812.c **** #if w3>0
 117:ws2812/light_ws2812.c **** #define w3_nops w3
 118:ws2812/light_ws2812.c **** #else
 119:ws2812/light_ws2812.c **** #define w3_nops  0
 120:ws2812/light_ws2812.c **** #endif
 121:ws2812/light_ws2812.c **** 
 122:ws2812/light_ws2812.c **** #define w_nop1  "nop      \n\t"
 123:ws2812/light_ws2812.c **** #define w_nop2  "rjmp .+0 \n\t"
 124:ws2812/light_ws2812.c **** #define w_nop4  w_nop2 w_nop2
 125:ws2812/light_ws2812.c **** #define w_nop8  w_nop4 w_nop4
 126:ws2812/light_ws2812.c **** #define w_nop16 w_nop8 w_nop8
 127:ws2812/light_ws2812.c **** 
 128:ws2812/light_ws2812.c **** static void inline ws2812_send_byte(uint8_t curbyte, uint8_t maskhi, uint8_t masklo)
 129:ws2812/light_ws2812.c **** {
 114               	.LM0:
 115               	.LFBB1:
 116               	/* prologue: function */
 117               	/* frame size = 0 */
 118               	/* stack size = 0 */
 119               	.L__stack_usage = 0
 130:ws2812/light_ws2812.c ****     uint8_t ctr;
 131:ws2812/light_ws2812.c ****     asm volatile(
 121               	.LM1:
 122 0000 982F      		mov r25,r24
 123               	/* #APP */
 124               	 ;  131 "ws2812/light_ws2812.c" 1
 125 0002 88E0      		       ldi   r24,8  
 126               		loop7:            
 127 0004 6BBB      		       out   27,r22 
 128 0006 0000      		nop      
 129 0008 97FF      		       sbrs  r25,7  
 130 000a 4BBB      		       out   27,r20 
 131 000c 990F      		       lsl   r25    
 132 000e 0000      		nop      
 133 0010 00C0      		rjmp .+0 
 134 0012 00C0      		rjmp .+0 
 135 0014 4BBB      		       out   27,r20 
 136 0016 8A95      		       dec   r24    
 137 0018 01F4      		       brne  loop7
 138               		
 139               	 ;  0 "" 2
 140               	/* #NOAPP */
 141 001a 0895      		ret
 143               	.Lscope1:
 145               		.stabd	78,0,0
 148               	.global	ws2812_setleds_constant
 150               	ws2812_setleds_constant:
 151               		.stabd	46,0,0
  40:ws2812/light_ws2812.c ****   uint8_t masklo,maskhi;
 153               	.LM2:
 154               	.LFBB2:
 155 001c 8F92      		push r8
 156 001e 9F92      		push r9
 157 0020 BF92      		push r11
 158 0022 CF92      		push r12
 159 0024 DF92      		push r13
 160 0026 EF92      		push r14
 161 0028 FF92      		push r15
 162 002a 0F93      		push r16
 163 002c 1F93      		push r17
 164 002e CF93      		push r28
 165 0030 DF93      		push r29
 166               	/* prologue: function */
 167               	/* frame size = 0 */
 168               	/* stack size = 11 */
 169               	.L__stack_usage = 11
 170 0032 6C01      		movw r12,r24
  45:ws2812/light_ws2812.c **** 
 172               	.LM3:
 173 0034 D19A      		sbi 0x1a,1
  47:ws2812/light_ws2812.c ****   maskhi |=        ws2812_PORTREG;
 175               	.LM4:
 176 0036 9BB3      		in r25,0x1b
 177 0038 9D7F      		andi r25,lo8(-3)
 178 003a F92E      		mov r15,r25
  48:ws2812/light_ws2812.c **** 
 180               	.LM5:
 181 003c 9BB3      		in r25,0x1b
 182 003e 9260      		ori r25,lo8(2)
 183 0040 E92E      		mov r14,r25
  50:ws2812/light_ws2812.c ****   cli();
 185               	.LM6:
 186 0042 BFB6      		in r11,__SREG__
  51:ws2812/light_ws2812.c **** 
 188               	.LM7:
 189               	/* #APP */
 190               	 ;  51 "ws2812/light_ws2812.c" 1
 191 0044 F894      		cli
 192               	 ;  0 "" 2
  53:ws2812/light_ws2812.c ****     uint8_t i;
 194               	.LM8:
 195               	/* #NOAPP */
 196 0046 EB01      		movw r28,r22
 197 0048 4601      		movw r8,r12
 198 004a 83E0      		ldi r24,3
 199 004c 880E      		add r8,r24
 200 004e 911C      		adc r9,__zero_reg__
 201               	.L3:
 202 0050 2097      		sbiw r28,0
 203 0052 01F0      		breq .L5
 204 0054 8601      		movw r16,r12
 205               	.L4:
 206               	.LBB12:
  56:ws2812/light_ws2812.c ****     }
 208               	.LM9:
 209 0056 4F2D      		mov r20,r15
 210 0058 6E2D      		mov r22,r14
 211 005a F801      		movw r30,r16
 212 005c 8191      		ld r24,Z+
 213 005e 8F01      		movw r16,r30
 214 0060 00D0      		rcall ws2812_send_byte
  55:ws2812/light_ws2812.c ****       ws2812_send_byte(((uint8_t *)ledval)[i], maskhi, masklo);
 216               	.LM10:
 217 0062 0815      		cp r16,r8
 218 0064 1905      		cpc r17,r9
 219 0066 01F4      		brne .L4
 220 0068 2197      		sbiw r28,1
 221 006a 00C0      		rjmp .L3
 222               	.L5:
 223               	.LBE12:
  59:ws2812/light_ws2812.c ****   _delay_us(50);
 225               	.LM11:
 226 006c BFBE      		out __SREG__,r11
 227               	.LBB13:
 228               	.LBB14:
 230               	.Ltext1:
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib/avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/lib/avr/include/util/delay.h **** #endif
  41:/usr/lib/avr/include/util/delay.h **** 
  42:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  45:/usr/lib/avr/include/util/delay.h **** 
  46:/usr/lib/avr/include/util/delay.h **** /** \file */
  47:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/lib/avr/include/util/delay.h ****     \code
  49:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/lib/avr/include/util/delay.h ****     \endcode
  53:/usr/lib/avr/include/util/delay.h **** 
  54:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/lib/avr/include/util/delay.h ****     used.
  58:/usr/lib/avr/include/util/delay.h **** 
  59:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/lib/avr/include/util/delay.h **** 
  68:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/lib/avr/include/util/delay.h **** 
  77:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/lib/avr/include/util/delay.h **** 
  81:/usr/lib/avr/include/util/delay.h **** */
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/lib/avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/lib/avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/lib/avr/include/util/delay.h **** #endif
  87:/usr/lib/avr/include/util/delay.h **** 
  88:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/lib/avr/include/util/delay.h **** #endif
  93:/usr/lib/avr/include/util/delay.h **** 
  94:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/lib/avr/include/util/delay.h **** #endif
  97:/usr/lib/avr/include/util/delay.h **** 
  98:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 102:/usr/lib/avr/include/util/delay.h **** #endif
 103:/usr/lib/avr/include/util/delay.h **** 
 104:/usr/lib/avr/include/util/delay.h **** /**
 105:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/lib/avr/include/util/delay.h **** 
 107:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/lib/avr/include/util/delay.h **** 
 109:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/lib/avr/include/util/delay.h **** 
 112:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/lib/avr/include/util/delay.h **** 
 114:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/lib/avr/include/util/delay.h **** 
 120:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/lib/avr/include/util/delay.h **** 
 125:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/lib/avr/include/util/delay.h **** 
 132:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/lib/avr/include/util/delay.h **** 
 140:/usr/lib/avr/include/util/delay.h ****  */
 141:/usr/lib/avr/include/util/delay.h **** void
 142:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/lib/avr/include/util/delay.h **** {
 144:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 145:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 146:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 147:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 148:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 149:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 150:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 153:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 154:/usr/lib/avr/include/util/delay.h **** 
 155:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 156:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 157:/usr/lib/avr/include/util/delay.h **** 
 158:/usr/lib/avr/include/util/delay.h **** 	#else
 159:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 160:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 161:/usr/lib/avr/include/util/delay.h **** 	#endif
 162:/usr/lib/avr/include/util/delay.h **** 
 163:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 164:/usr/lib/avr/include/util/delay.h **** 
 165:/usr/lib/avr/include/util/delay.h **** #else
 166:/usr/lib/avr/include/util/delay.h **** 	uint16_t __ticks;
 167:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 168:/usr/lib/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 169:/usr/lib/avr/include/util/delay.h **** 		__ticks = 1;
 170:/usr/lib/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 171:/usr/lib/avr/include/util/delay.h **** 	{
 172:/usr/lib/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 173:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 174:/usr/lib/avr/include/util/delay.h **** 		while(__ticks)
 175:/usr/lib/avr/include/util/delay.h **** 		{
 176:/usr/lib/avr/include/util/delay.h **** 			// wait 1/10 ms
 177:/usr/lib/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 178:/usr/lib/avr/include/util/delay.h **** 			__ticks --;
 179:/usr/lib/avr/include/util/delay.h **** 		}
 180:/usr/lib/avr/include/util/delay.h **** 		return;
 181:/usr/lib/avr/include/util/delay.h **** 	}
 182:/usr/lib/avr/include/util/delay.h **** 	else
 183:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 184:/usr/lib/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 185:/usr/lib/avr/include/util/delay.h **** #endif
 186:/usr/lib/avr/include/util/delay.h **** }
 187:/usr/lib/avr/include/util/delay.h **** 
 188:/usr/lib/avr/include/util/delay.h **** /**
 189:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 190:/usr/lib/avr/include/util/delay.h **** 
 191:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 192:/usr/lib/avr/include/util/delay.h **** 
 193:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 194:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 195:/usr/lib/avr/include/util/delay.h **** 
 196:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 197:/usr/lib/avr/include/util/delay.h **** 
 198:/usr/lib/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 199:/usr/lib/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 200:/usr/lib/avr/include/util/delay.h ****    will not be informed about this case.
 201:/usr/lib/avr/include/util/delay.h **** 
 202:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 203:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 204:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 205:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0us.
 206:/usr/lib/avr/include/util/delay.h ****   
 207:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 208:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 209:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 210:/usr/lib/avr/include/util/delay.h **** 
 211:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 212:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 213:/usr/lib/avr/include/util/delay.h ****  
 214:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_us(double __us) with 
 215:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible.
 216:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 217:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 218:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 219:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 220:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 221:/usr/lib/avr/include/util/delay.h **** 
 222:/usr/lib/avr/include/util/delay.h ****  */
 223:/usr/lib/avr/include/util/delay.h **** void
 224:/usr/lib/avr/include/util/delay.h **** _delay_us(double __us)
 225:/usr/lib/avr/include/util/delay.h **** {
 226:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 227:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 228:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 229:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 230:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 231:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 232:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 233:/usr/lib/avr/include/util/delay.h **** 
 234:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 235:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 236:/usr/lib/avr/include/util/delay.h **** 
 237:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 238:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 239:/usr/lib/avr/include/util/delay.h **** 
 240:/usr/lib/avr/include/util/delay.h **** 	#else
 241:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 242:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 243:/usr/lib/avr/include/util/delay.h **** 	#endif
 244:/usr/lib/avr/include/util/delay.h **** 
 245:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 232               	.LM12:
 233 006e F5E8      		ldi r31,lo8(-123)
 234 0070 FA95      	1:	dec r31
 235 0072 01F4      		brne 1b
 236 0074 0000      		nop
 237               	/* epilogue start */
 238               	.LBE14:
 239               	.LBE13:
 241               	.Ltext2:
  61:ws2812/light_ws2812.c **** 
 243               	.LM13:
 244 0076 DF91      		pop r29
 245 0078 CF91      		pop r28
 246 007a 1F91      		pop r17
 247 007c 0F91      		pop r16
 248 007e FF90      		pop r15
 249 0080 EF90      		pop r14
 250 0082 DF90      		pop r13
 251 0084 CF90      		pop r12
 252 0086 BF90      		pop r11
 253 0088 9F90      		pop r9
 254 008a 8F90      		pop r8
 255 008c 0895      		ret
 262               	.Lscope2:
 264               		.stabd	78,0,0
 267               	.global	ws2812_setleds_constant_rgbw
 269               	ws2812_setleds_constant_rgbw:
 270               		.stabd	46,0,0
  64:ws2812/light_ws2812.c ****   uint8_t masklo,maskhi;
 272               	.LM14:
 273               	.LFBB3:
 274 008e 8F92      		push r8
 275 0090 9F92      		push r9
 276 0092 BF92      		push r11
 277 0094 CF92      		push r12
 278 0096 DF92      		push r13
 279 0098 EF92      		push r14
 280 009a FF92      		push r15
 281 009c 0F93      		push r16
 282 009e 1F93      		push r17
 283 00a0 CF93      		push r28
 284 00a2 DF93      		push r29
 285               	/* prologue: function */
 286               	/* frame size = 0 */
 287               	/* stack size = 11 */
 288               	.L__stack_usage = 11
 289 00a4 6C01      		movw r12,r24
  69:ws2812/light_ws2812.c **** 
 291               	.LM15:
 292 00a6 D19A      		sbi 0x1a,1
  71:ws2812/light_ws2812.c ****   maskhi |=        ws2812_PORTREG;
 294               	.LM16:
 295 00a8 9BB3      		in r25,0x1b
 296 00aa 9D7F      		andi r25,lo8(-3)
 297 00ac F92E      		mov r15,r25
  72:ws2812/light_ws2812.c **** 
 299               	.LM17:
 300 00ae 9BB3      		in r25,0x1b
 301 00b0 9260      		ori r25,lo8(2)
 302 00b2 E92E      		mov r14,r25
  74:ws2812/light_ws2812.c ****   cli();
 304               	.LM18:
 305 00b4 BFB6      		in r11,__SREG__
  75:ws2812/light_ws2812.c **** 
 307               	.LM19:
 308               	/* #APP */
 309               	 ;  75 "ws2812/light_ws2812.c" 1
 310 00b6 F894      		cli
 311               	 ;  0 "" 2
  77:ws2812/light_ws2812.c ****     uint8_t i;
 313               	.LM20:
 314               	/* #NOAPP */
 315 00b8 EB01      		movw r28,r22
 316 00ba 4601      		movw r8,r12
 317 00bc 84E0      		ldi r24,4
 318 00be 880E      		add r8,r24
 319 00c0 911C      		adc r9,__zero_reg__
 320               	.L9:
 321 00c2 2097      		sbiw r28,0
 322 00c4 01F0      		breq .L11
 323 00c6 8601      		movw r16,r12
 324               	.L10:
 325               	.LBB15:
  80:ws2812/light_ws2812.c ****     }
 327               	.LM21:
 328 00c8 4F2D      		mov r20,r15
 329 00ca 6E2D      		mov r22,r14
 330 00cc F801      		movw r30,r16
 331 00ce 8191      		ld r24,Z+
 332 00d0 8F01      		movw r16,r30
 333 00d2 00D0      		rcall ws2812_send_byte
  79:ws2812/light_ws2812.c ****       ws2812_send_byte(((uint8_t *)ledval)[i], maskhi, masklo);
 335               	.LM22:
 336 00d4 0815      		cp r16,r8
 337 00d6 1905      		cpc r17,r9
 338 00d8 01F4      		brne .L10
 339 00da 2197      		sbiw r28,1
 340 00dc 00C0      		rjmp .L9
 341               	.L11:
 342               	.LBE15:
  83:ws2812/light_ws2812.c ****   _delay_us(80);
 344               	.LM23:
 345 00de BFBE      		out __SREG__,r11
 346               	.LBB16:
 347               	.LBB17:
 349               	.Ltext3:
 351               	.LM24:
 352 00e0 F5ED      		ldi r31,lo8(-43)
 353 00e2 FA95      	1:	dec r31
 354 00e4 01F4      		brne 1b
 355 00e6 0000      		nop
 356               	/* epilogue start */
 357               	.LBE17:
 358               	.LBE16:
 360               	.Ltext4:
  85:ws2812/light_ws2812.c **** 
 362               	.LM25:
 363 00e8 DF91      		pop r29
 364 00ea CF91      		pop r28
 365 00ec 1F91      		pop r17
 366 00ee 0F91      		pop r16
 367 00f0 FF90      		pop r15
 368 00f2 EF90      		pop r14
 369 00f4 DF90      		pop r13
 370 00f6 CF90      		pop r12
 371 00f8 BF90      		pop r11
 372 00fa 9F90      		pop r9
 373 00fc 8F90      		pop r8
 374 00fe 0895      		ret
 381               	.Lscope3:
 383               		.stabd	78,0,0
 387               	.global	ws2812_sendarray_mask
 389               	ws2812_sendarray_mask:
 390               		.stabd	46,0,0
 132:ws2812/light_ws2812.c ****     "       ldi   %0,8  \n\t"
 133:ws2812/light_ws2812.c ****     "loop%=:            \n\t"	 // loop 
 134:ws2812/light_ws2812.c ****     "       out   %2,%3 \n\t"    // PORT = hi '1' [01] '0' [01] - re
 135:ws2812/light_ws2812.c **** #if (w1_nops&1)
 136:ws2812/light_ws2812.c **** w_nop1
 137:ws2812/light_ws2812.c **** #endif
 138:ws2812/light_ws2812.c **** #if (w1_nops&2)
 139:ws2812/light_ws2812.c **** w_nop2
 140:ws2812/light_ws2812.c **** #endif
 141:ws2812/light_ws2812.c **** #if (w1_nops&4)
 142:ws2812/light_ws2812.c **** w_nop4
 143:ws2812/light_ws2812.c **** #endif
 144:ws2812/light_ws2812.c **** #if (w1_nops&8)
 145:ws2812/light_ws2812.c **** w_nop8
 146:ws2812/light_ws2812.c **** #endif
 147:ws2812/light_ws2812.c **** #if (w1_nops&16)
 148:ws2812/light_ws2812.c **** w_nop16
 149:ws2812/light_ws2812.c **** #endif
 150:ws2812/light_ws2812.c ****     "       sbrs  %1,7  \n\t"    // if(x & x)	'1' [03] '0' [02]
 151:ws2812/light_ws2812.c ****     "       out   %2,%4 \n\t"    //				'1' [--] '0' [03] - fe-low
 152:ws2812/light_ws2812.c ****     "       lsl   %1    \n\t"    //				'1' [04] '0' [04]
 153:ws2812/light_ws2812.c **** #if (w2_nops&1)
 154:ws2812/light_ws2812.c ****   w_nop1
 155:ws2812/light_ws2812.c **** #endif
 156:ws2812/light_ws2812.c **** #if (w2_nops&2)
 157:ws2812/light_ws2812.c ****   w_nop2
 158:ws2812/light_ws2812.c **** #endif
 159:ws2812/light_ws2812.c **** #if (w2_nops&4)
 160:ws2812/light_ws2812.c ****   w_nop4
 161:ws2812/light_ws2812.c **** #endif
 162:ws2812/light_ws2812.c **** #if (w2_nops&8)
 163:ws2812/light_ws2812.c ****   w_nop8
 164:ws2812/light_ws2812.c **** #endif
 165:ws2812/light_ws2812.c **** #if (w2_nops&16)
 166:ws2812/light_ws2812.c ****   w_nop16 
 167:ws2812/light_ws2812.c **** #endif
 168:ws2812/light_ws2812.c ****     "       out   %2,%4 \n\t"    //  '1' [+1] '0' [+1] - fe-high
 169:ws2812/light_ws2812.c **** #if (w3_nops&1)
 170:ws2812/light_ws2812.c **** w_nop1
 171:ws2812/light_ws2812.c **** #endif
 172:ws2812/light_ws2812.c **** #if (w3_nops&2)
 173:ws2812/light_ws2812.c **** w_nop2
 174:ws2812/light_ws2812.c **** #endif
 175:ws2812/light_ws2812.c **** #if (w3_nops&4)
 176:ws2812/light_ws2812.c **** w_nop4
 177:ws2812/light_ws2812.c **** #endif
 178:ws2812/light_ws2812.c **** #if (w3_nops&8)
 179:ws2812/light_ws2812.c **** w_nop8
 180:ws2812/light_ws2812.c **** #endif
 181:ws2812/light_ws2812.c **** #if (w3_nops&16)
 182:ws2812/light_ws2812.c **** w_nop16
 183:ws2812/light_ws2812.c **** #endif
 184:ws2812/light_ws2812.c **** 
 185:ws2812/light_ws2812.c ****     "       dec   %0    \n\t"    //  '1' [+2] '0' [+2]
 186:ws2812/light_ws2812.c ****     "       brne  loop%=\n\t"    //  '1' [+3] '0' [+4]
 187:ws2812/light_ws2812.c ****     :	"=&d" (ctr)
 188:ws2812/light_ws2812.c ****     :	"r" (curbyte), "I" (_SFR_IO_ADDR(ws2812_PORTREG)), "r" (maskhi), "r" (masklo)
 189:ws2812/light_ws2812.c ****     );
 190:ws2812/light_ws2812.c **** }
 191:ws2812/light_ws2812.c **** 
 192:ws2812/light_ws2812.c **** void inline ws2812_sendarray_mask(uint8_t *data,uint16_t datlen,uint8_t maskhi)
 193:ws2812/light_ws2812.c **** {
 392               	.LM26:
 393               	.LFBB4:
 394 0100 DF92      		push r13
 395 0102 EF92      		push r14
 396 0104 FF92      		push r15
 397 0106 0F93      		push r16
 398 0108 1F93      		push r17
 399 010a CF93      		push r28
 400 010c DF93      		push r29
 401               	/* prologue: function */
 402               	/* frame size = 0 */
 403               	/* stack size = 7 */
 404               	.L__stack_usage = 7
 194:ws2812/light_ws2812.c ****   uint8_t curbyte,masklo;
 195:ws2812/light_ws2812.c ****   uint8_t sreg_prev;
 196:ws2812/light_ws2812.c **** 
 197:ws2812/light_ws2812.c ****   ws2812_DDRREG |= maskhi; // Enable output
 406               	.LM27:
 407 010e 2AB3      		in r18,0x1a
 408 0110 242B      		or r18,r20
 409 0112 2ABB      		out 0x1a,r18
 198:ws2812/light_ws2812.c **** 
 199:ws2812/light_ws2812.c ****   masklo	=~maskhi&ws2812_PORTREG;
 411               	.LM28:
 412 0114 2BB3      		in r18,0x1b
 413 0116 F42E      		mov r15,r20
 414 0118 F094      		com r15
 415 011a F222      		and r15,r18
 200:ws2812/light_ws2812.c ****   maskhi |=        ws2812_PORTREG;
 417               	.LM29:
 418 011c 2BB3      		in r18,0x1b
 419 011e E42E      		mov r14,r20
 420 0120 E22A      		or r14,r18
 201:ws2812/light_ws2812.c **** 
 202:ws2812/light_ws2812.c ****   sreg_prev=SREG;
 422               	.LM30:
 423 0122 DFB6      		in r13,__SREG__
 203:ws2812/light_ws2812.c ****   cli();
 425               	.LM31:
 426               	/* #APP */
 427               	 ;  203 "ws2812/light_ws2812.c" 1
 428 0124 F894      		cli
 429               	 ;  0 "" 2
 430               	/* #NOAPP */
 431 0126 EC01      		movw r28,r24
 432 0128 8C01      		movw r16,r24
 433 012a 060F      		add r16,r22
 434 012c 171F      		adc r17,r23
 435               	.L14:
 204:ws2812/light_ws2812.c **** 
 205:ws2812/light_ws2812.c ****   while (datlen--) {
 437               	.LM32:
 438 012e C017      		cp r28,r16
 439 0130 D107      		cpc r29,r17
 440 0132 01F0      		breq .L16
 206:ws2812/light_ws2812.c ****     curbyte=*data++;
 207:ws2812/light_ws2812.c ****     ws2812_send_byte(curbyte, maskhi, masklo);
 442               	.LM33:
 443 0134 4F2D      		mov r20,r15
 444 0136 6E2D      		mov r22,r14
 445 0138 8991      		ld r24,Y+
 446 013a 00D0      		rcall ws2812_send_byte
 447 013c 00C0      		rjmp .L14
 448               	.L16:
 208:ws2812/light_ws2812.c ****   }
 209:ws2812/light_ws2812.c **** 
 210:ws2812/light_ws2812.c ****   SREG=sreg_prev;
 450               	.LM34:
 451 013e DFBE      		out __SREG__,r13
 452               	/* epilogue start */
 211:ws2812/light_ws2812.c **** }
 454               	.LM35:
 455 0140 DF91      		pop r29
 456 0142 CF91      		pop r28
 457 0144 1F91      		pop r17
 458 0146 0F91      		pop r16
 459 0148 FF90      		pop r15
 460 014a EF90      		pop r14
 461 014c DF90      		pop r13
 462 014e 0895      		ret
 468               	.Lscope4:
 470               		.stabd	78,0,0
 475               	.global	ws2812_setleds_pin
 477               	ws2812_setleds_pin:
 478               		.stabd	46,0,0
  25:ws2812/light_ws2812.c ****   ws2812_sendarray_mask((uint8_t*)ledarray,leds+leds+leds,pinmask);
 480               	.LM36:
 481               	.LFBB5:
 482               	/* prologue: function */
 483               	/* frame size = 0 */
 484               	/* stack size = 0 */
 485               	.L__stack_usage = 0
  26:ws2812/light_ws2812.c ****   _delay_us(50);
 487               	.LM37:
 488 0150 9B01      		movw r18,r22
 489 0152 220F      		lsl r18
 490 0154 331F      		rol r19
 491 0156 620F      		add r22,r18
 492 0158 731F      		adc r23,r19
 493 015a 00D0      		rcall ws2812_sendarray_mask
 494               	.LBB18:
 495               	.LBB19:
 497               	.Ltext5:
 499               	.LM38:
 500 015c 85E8      		ldi r24,lo8(-123)
 501 015e 8A95      	1:	dec r24
 502 0160 01F4      		brne 1b
 503 0162 0000      		nop
 504 0164 0895      		ret
 505               	.LBE19:
 506               	.LBE18:
 508               	.Lscope5:
 510               		.stabd	78,0,0
 514               	.global	ws2812_setleds
 516               	ws2812_setleds:
 517               		.stabd	46,0,0
 519               	.Ltext6:
  20:ws2812/light_ws2812.c ****    ws2812_setleds_pin(ledarray,leds, _BV(ws2812_pin));
 521               	.LM39:
 522               	.LFBB6:
 523               	/* prologue: function */
 524               	/* frame size = 0 */
 525               	/* stack size = 0 */
 526               	.L__stack_usage = 0
  21:ws2812/light_ws2812.c **** }
 528               	.LM40:
 529 0166 42E0      		ldi r20,lo8(2)
 530 0168 00C0      		rjmp ws2812_setleds_pin
 532               	.Lscope6:
 534               		.stabd	78,0,0
 538               	.global	ws2812_setleds_rgbw
 540               	ws2812_setleds_rgbw:
 541               		.stabd	46,0,0
  32:ws2812/light_ws2812.c ****   ws2812_sendarray_mask((uint8_t*)ledarray,leds<<2,_BV(ws2812_pin));
 543               	.LM41:
 544               	.LFBB7:
 545               	/* prologue: function */
 546               	/* frame size = 0 */
 547               	/* stack size = 0 */
 548               	.L__stack_usage = 0
  33:ws2812/light_ws2812.c ****   _delay_us(80);
 550               	.LM42:
 551 016a 660F      		lsl r22
 552 016c 771F      		rol r23
 553 016e 660F      		lsl r22
 554 0170 771F      		rol r23
 555 0172 42E0      		ldi r20,lo8(2)
 556 0174 00D0      		rcall ws2812_sendarray_mask
 557               	.LBB20:
 558               	.LBB21:
 560               	.Ltext7:
 562               	.LM43:
 563 0176 85ED      		ldi r24,lo8(-43)
 564 0178 8A95      	1:	dec r24
 565 017a 01F4      		brne 1b
 566 017c 0000      		nop
 567 017e 0895      		ret
 568               	.LBE21:
 569               	.LBE20:
 571               	.Lscope7:
 573               		.stabd	78,0,0
 577               	.global	ws2812_sendarray
 579               	ws2812_sendarray:
 580               		.stabd	46,0,0
 582               	.Ltext8:
  88:ws2812/light_ws2812.c ****   ws2812_sendarray_mask(data,datlen,_BV(ws2812_pin));
 584               	.LM44:
 585               	.LFBB8:
 586               	/* prologue: function */
 587               	/* frame size = 0 */
 588               	/* stack size = 0 */
 589               	.L__stack_usage = 0
  89:ws2812/light_ws2812.c **** }
 591               	.LM45:
 592 0180 42E0      		ldi r20,lo8(2)
 593 0182 00C0      		rjmp ws2812_sendarray_mask
 595               	.Lscope8:
 597               		.stabd	78,0,0
 599               	.Letext0:
 600               		.ident	"GCC: (GNU) 4.9.2"
DEFINED SYMBOLS
                            *ABS*:00000000 light_ws2812.c
     /tmp/ccFx86dc.s:2      *ABS*:0000003e __SP_H__
     /tmp/ccFx86dc.s:3      *ABS*:0000003d __SP_L__
     /tmp/ccFx86dc.s:4      *ABS*:0000003f __SREG__
     /tmp/ccFx86dc.s:5      *ABS*:00000000 __tmp_reg__
     /tmp/ccFx86dc.s:6      *ABS*:00000001 __zero_reg__
     /tmp/ccFx86dc.s:111    .text:00000000 ws2812_send_byte
     /tmp/ccFx86dc.s:126    .text:00000004 loop7
     /tmp/ccFx86dc.s:150    .text:0000001c ws2812_setleds_constant
     /tmp/ccFx86dc.s:269    .text:0000008e ws2812_setleds_constant_rgbw
     /tmp/ccFx86dc.s:389    .text:00000100 ws2812_sendarray_mask
     /tmp/ccFx86dc.s:477    .text:00000150 ws2812_setleds_pin
     /tmp/ccFx86dc.s:516    .text:00000166 ws2812_setleds
     /tmp/ccFx86dc.s:540    .text:0000016a ws2812_setleds_rgbw
     /tmp/ccFx86dc.s:579    .text:00000180 ws2812_sendarray

NO UNDEFINED SYMBOLS
