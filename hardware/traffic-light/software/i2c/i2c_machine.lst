   1               		.file	"i2c_machine.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   9               		.text
  10               	.Ltext0:
 103               	.global	__vector_7
 105               	__vector_7:
 106               		.stabd	46,0,0
   1:i2c/i2c_machine.c **** /*
   2:i2c/i2c_machine.c ****  * Copyright Brian Starkey 2014 <stark3y@gmail.com>
   3:i2c/i2c_machine.c ****  *
   4:i2c/i2c_machine.c ****  * This program is free software: you can redistribute it and/or modify
   5:i2c/i2c_machine.c ****  * it under the terms of version 2 of the GNU General Public License as
   6:i2c/i2c_machine.c ****  * published by the Free Software Foundation.
   7:i2c/i2c_machine.c ****  *
   8:i2c/i2c_machine.c ****  * This program is distributed in the hope that it will be useful,
   9:i2c/i2c_machine.c ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  10:i2c/i2c_machine.c ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  11:i2c/i2c_machine.c ****  * GNU General Public License for more details.
  12:i2c/i2c_machine.c ****  *
  13:i2c/i2c_machine.c ****  * You should have received a copy of the GNU General Public License
  14:i2c/i2c_machine.c ****  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  15:i2c/i2c_machine.c ****  *
  16:i2c/i2c_machine.c ****  */
  17:i2c/i2c_machine.c **** 
  18:i2c/i2c_machine.c **** #define DEBUG
  19:i2c/i2c_machine.c **** 
  20:i2c/i2c_machine.c **** #include <avr/io.h>
  21:i2c/i2c_machine.c **** #include <avr/interrupt.h>
  22:i2c/i2c_machine.c **** #include <stdint.h>
  23:i2c/i2c_machine.c **** #include "i2c_slave_defs.h"
  24:i2c/i2c_machine.c **** #include "i2c_machine.h"
  25:i2c/i2c_machine.c **** 
  26:i2c/i2c_machine.c **** #define I2C_SDA_DIR_OUT 1
  27:i2c/i2c_machine.c **** #define I2C_SDA_DIR_IN 0
  28:i2c/i2c_machine.c **** 
  29:i2c/i2c_machine.c **** #define NAK() USIDR = 0x80
  30:i2c/i2c_machine.c **** #define ACK() USIDR = 0x00
  31:i2c/i2c_machine.c **** 
  32:i2c/i2c_machine.c **** #define I2C_STATE_ADDR_MATCH   0
  33:i2c/i2c_machine.c **** #define I2C_STATE_REG_ADDR     1
  34:i2c/i2c_machine.c **** #define I2C_STATE_MASTER_READ  2
  35:i2c/i2c_machine.c **** #define I2C_STATE_MASTER_WRITE 3
  36:i2c/i2c_machine.c **** #define I2C_STATE_IDLE         4
  37:i2c/i2c_machine.c **** 
  38:i2c/i2c_machine.c **** #ifdef DEBUG
  39:i2c/i2c_machine.c **** #define LED_ON() PORTB |= 0x2
  40:i2c/i2c_machine.c **** #define LED_OFF() PORTB &= ~0x2
  41:i2c/i2c_machine.c **** #define LED_FLICKER() LED_OFF(); LED_ON()
  42:i2c/i2c_machine.c **** #else
  43:i2c/i2c_machine.c **** #define LED_ON()
  44:i2c/i2c_machine.c **** #define LED_OFF()
  45:i2c/i2c_machine.c **** #define LED_FLICKER()
  46:i2c/i2c_machine.c **** #endif
  47:i2c/i2c_machine.c **** 
  48:i2c/i2c_machine.c **** volatile uint8_t i2c_update = 0;
  49:i2c/i2c_machine.c **** volatile uint8_t i2c_state = 0;
  50:i2c/i2c_machine.c **** volatile uint8_t i2c_offset = 0;
  51:i2c/i2c_machine.c **** 
  52:i2c/i2c_machine.c **** /* USI i2c Slave State Machine
  53:i2c/i2c_machine.c ****  * ===========================
  54:i2c/i2c_machine.c ****  *
  55:i2c/i2c_machine.c ****  * 5 States:
  56:i2c/i2c_machine.c ****  *     0 I2C_STATE_ADDR_MATCH
  57:i2c/i2c_machine.c ****  *       Waiting for address (start)
  58:i2c/i2c_machine.c ****  *
  59:i2c/i2c_machine.c ****  *     1 I2C_STATE_REG_ADDR
  60:i2c/i2c_machine.c ****  *       Receive register address*
  61:i2c/i2c_machine.c ****  *
  62:i2c/i2c_machine.c ****  *     2 I2C_STATE_MASTER_READ
  63:i2c/i2c_machine.c ****  *       Transmit data to master
  64:i2c/i2c_machine.c ****  *
  65:i2c/i2c_machine.c ****  *     3 I2C_STATE_MASTER_WRITE
  66:i2c/i2c_machine.c ****  *       Receive data from master
  67:i2c/i2c_machine.c ****  *
  68:i2c/i2c_machine.c ****  *     4 I2C_STATE_IDLE
  69:i2c/i2c_machine.c ****  *       Bus idle/address not matched
  70:i2c/i2c_machine.c ****  *
  71:i2c/i2c_machine.c ****  * Valid state transitions:
  72:i2c/i2c_machine.c ****  *      __To__________
  73:i2c/i2c_machine.c ****  *      0  1  2  3  4
  74:i2c/i2c_machine.c ****  * F 0|    a  b     h
  75:i2c/i2c_machine.c ****  * r 1|          d  ci
  76:i2c/i2c_machine.c ****  * o 2|       f     e
  77:i2c/i2c_machine.c ****  * m 3|          g  c
  78:i2c/i2c_machine.c ****  *   4| j
  79:i2c/i2c_machine.c ****  *
  80:i2c/i2c_machine.c ****  * Transition j - Start of transaction
  81:i2c/i2c_machine.c ****  *  I2C_STATE_IDLE -> I2C_STATE_ADDR_MATCH
  82:i2c/i2c_machine.c ****  *  Cond:   Start condition interrupt
  83:i2c/i2c_machine.c ****  *  Action: None.
  84:i2c/i2c_machine.c ****  *
  85:i2c/i2c_machine.c ****  * Transition h - Address not matched.
  86:i2c/i2c_machine.c ****  *  I2C_STATE_ADDR_MATCH -> I2C_STATE_IDLE
  87:i2c/i2c_machine.c ****  *  Cond:   Pre-ack. Address doesn't match
  88:i2c/i2c_machine.c ****  *  Action: NAK.
  89:i2c/i2c_machine.c ****  *
  90:i2c/i2c_machine.c ****  * Transition a - Address matched, write mode
  91:i2c/i2c_machine.c ****  *  I2C_STATE_ADDR_MATCH -> I2C_STATE_REG_ADDR
  92:i2c/i2c_machine.c ****  *  Cond:   Pre-ack. Address matches, bit0 == 0
  93:i2c/i2c_machine.c ****  *  Action: ACK, Reset reg pointer.
  94:i2c/i2c_machine.c ****  *
  95:i2c/i2c_machine.c ****  * Transition b - Address matched, read mode
  96:i2c/i2c_machine.c ****  *  I2C_STATE_ADDR_MATCH -> I2C_STATE_MASTER_READ
  97:i2c/i2c_machine.c ****  *  Cond:   Pre-ack. Address matches, bit0 == 1
  98:i2c/i2c_machine.c ****  *  Action: ACK.
  99:i2c/i2c_machine.c ****  *
 100:i2c/i2c_machine.c ****  * Transition c - Write finished
 101:i2c/i2c_machine.c ****  *  I2C_STATE_XXX -> I2C_STATE_IDLE
 102:i2c/i2c_machine.c ****  *  Cond:   Stop flag is set.
 103:i2c/i2c_machine.c ****  *  Action: None.
 104:i2c/i2c_machine.c ****  *
 105:i2c/i2c_machine.c ****  * Transition d - Initialise write
 106:i2c/i2c_machine.c ****  *  I2C_STATE_REG_ADDR -> I2C_STATE_MASTER_WRITE
 107:i2c/i2c_machine.c ****  *  Cond:   Pre-ack.
 108:i2c/i2c_machine.c ****  *  Action: ACK, reg_ptr = USIDR.
 109:i2c/i2c_machine.c ****  *
 110:i2c/i2c_machine.c ****  * Transition i - Invalid reg addr
 111:i2c/i2c_machine.c ****  *  I2C_STATE_REG_ADDR -> I2C_STATE_IDLE
 112:i2c/i2c_machine.c ****  *  Cond:   Pre-ack, USIDR > N_REG - 1
 113:i2c/i2c_machine.c ****  *  Action: NAK.
 114:i2c/i2c_machine.c ****  *
 115:i2c/i2c_machine.c ****  * Transition e - Read finished
 116:i2c/i2c_machine.c ****  *  I2C_STATE_MASTER_READ -> I2C_STATE_IDLE
 117:i2c/i2c_machine.c ****  *  Cond:   Post-ack. Master NAK'd.
 118:i2c/i2c_machine.c ****  *  Action: None.
 119:i2c/i2c_machine.c ****  *
 120:i2c/i2c_machine.c ****  * Transition f - Read continues
 121:i2c/i2c_machine.c ****  *  I2C_STATE_MASTER_READ -> I2C_STATE_MASTER_READ
 122:i2c/i2c_machine.c ****  *  Cond:   Post-ack. Master ACK'd.
 123:i2c/i2c_machine.c ****  *  Action: USIDR = *reg_ptr++
 124:i2c/i2c_machine.c ****  *
 125:i2c/i2c_machine.c ****  * Transition g - Write continues
 126:i2c/i2c_machine.c ****  *  I2C_STATE_MASTER_WRITE -> I2C_STATE_MASTER_WRITE
 127:i2c/i2c_machine.c ****  *  Cond:   Pre-ack.
 128:i2c/i2c_machine.c ****  *  Action: ACK, *reg_ptr++ = USIDR
 129:i2c/i2c_machine.c ****  *
 130:i2c/i2c_machine.c ****  */
 131:i2c/i2c_machine.c **** 
 132:i2c/i2c_machine.c ****  /*
 133:i2c/i2c_machine.c ****   * For some reason, avr-libc uses different vector names for the USI
 134:i2c/i2c_machine.c ****   * on different chips! We have to workaround that here
 135:i2c/i2c_machine.c ****   */
 136:i2c/i2c_machine.c **** #if defined(USI_START_vect)
 137:i2c/i2c_machine.c **** ISR(USI_START_vect)
 138:i2c/i2c_machine.c **** #elif defined(USI_STRT_vect)
 139:i2c/i2c_machine.c **** ISR(USI_STRT_vect)
 140:i2c/i2c_machine.c **** #else
 141:i2c/i2c_machine.c **** #error "Couldn't figure out what i2c start interrupt to use!"
 142:i2c/i2c_machine.c **** #endif
 143:i2c/i2c_machine.c **** {
 108               	.LM0:
 109               	.LFBB1:
 110 0000 1F92      		push r1
 111 0002 0F92      		push r0
 112 0004 0FB6      		in r0,__SREG__
 113 0006 0F92      		push r0
 114 0008 1124      		clr __zero_reg__
 115 000a 8F93      		push r24
 116               	/* prologue: Signal */
 117               	/* frame size = 0 */
 118               	/* stack size = 4 */
 119               	.L__stack_usage = 4
 144:i2c/i2c_machine.c **** 	i2c_state = 0;
 121               	.LM1:
 122 000c 1092 0000 		sts i2c_state,__zero_reg__
 123               	.L2:
 145:i2c/i2c_machine.c **** 	while (PINB & (1 << I2C_SCL));
 125               	.LM2:
 126 0010 B299      		sbic 0x16,2
 127 0012 00C0      		rjmp .L2
 146:i2c/i2c_machine.c **** 	USISR = 0xF0;
 129               	.LM3:
 130 0014 80EF      		ldi r24,lo8(-16)
 131 0016 8EB9      		out 0xe,r24
 132               	/* epilogue start */
 147:i2c/i2c_machine.c **** }
 134               	.LM4:
 135 0018 8F91      		pop r24
 136 001a 0F90      		pop r0
 137 001c 0FBE      		out __SREG__,r0
 138 001e 0F90      		pop r0
 139 0020 1F90      		pop r1
 140 0022 1895      		reti
 142               	.Lscope1:
 144               		.stabd	78,0,0
 146               	.global	__vector_8
 148               	__vector_8:
 149               		.stabd	46,0,0
 148:i2c/i2c_machine.c **** 
 149:i2c/i2c_machine.c **** #if defined(USI_OVERFLOW_vect)
 150:i2c/i2c_machine.c **** ISR(USI_OVERFLOW_vect)
 151:i2c/i2c_machine.c **** #elif defined(USI_OVF_vect)
 152:i2c/i2c_machine.c **** ISR(USI_OVF_vect)
 153:i2c/i2c_machine.c **** #else
 154:i2c/i2c_machine.c **** #error "Couldn't figure out what i2c overflow interrupt to use!"
 155:i2c/i2c_machine.c **** #endif
 156:i2c/i2c_machine.c **** {
 151               	.LM5:
 152               	.LFBB2:
 153 0024 1F92      		push r1
 154 0026 0F92      		push r0
 155 0028 0FB6      		in r0,__SREG__
 156 002a 0F92      		push r0
 157 002c 1124      		clr __zero_reg__
 158 002e 2F93      		push r18
 159 0030 8F93      		push r24
 160 0032 9F93      		push r25
 161 0034 EF93      		push r30
 162 0036 FF93      		push r31
 163               	/* prologue: Signal */
 164               	/* frame size = 0 */
 165               	/* stack size = 8 */
 166               	.L__stack_usage = 8
 157:i2c/i2c_machine.c **** 	static uint8_t post_ack = 0;
 158:i2c/i2c_machine.c **** 	/* Writing USISR directly has side effects! */
 159:i2c/i2c_machine.c **** 	uint8_t usisr_tmp = 0xD0;
 160:i2c/i2c_machine.c **** 	uint8_t sda_direction;
 161:i2c/i2c_machine.c **** 	uint8_t tmp;
 162:i2c/i2c_machine.c **** 
 163:i2c/i2c_machine.c **** 	if (!post_ack) {
 168               	.LM6:
 169 0038 8091 0000 		lds r24,post_ack.1505
 170 003c 8111      		cpse r24,__zero_reg__
 171 003e 00C0      		rjmp .L6
 164:i2c/i2c_machine.c **** 		/* Work that needs to be done before the ACK cycle */
 165:i2c/i2c_machine.c **** 		sda_direction = I2C_SDA_DIR_OUT;
 166:i2c/i2c_machine.c **** 
 167:i2c/i2c_machine.c **** 		switch (i2c_state) {
 173               	.LM7:
 174 0040 8091 0000 		lds r24,i2c_state
 175 0044 8130      		cpi r24,lo8(1)
 176 0046 01F0      		breq .L8
 177 0048 00F0      		brlo .L9
 178 004a 8230      		cpi r24,lo8(2)
 179 004c 01F0      		breq .L10
 180 004e 8330      		cpi r24,lo8(3)
 181 0050 01F0      		breq .+2
 182 0052 00C0      		rjmp .L25
 168:i2c/i2c_machine.c **** 		case I2C_STATE_ADDR_MATCH:
 169:i2c/i2c_machine.c **** 			tmp = USIDR >> 1;
 170:i2c/i2c_machine.c **** 			if (tmp && (tmp != I2C_SLAVE_ADDR)) {
 171:i2c/i2c_machine.c **** 				/* Transition h */
 172:i2c/i2c_machine.c **** 				i2c_state = I2C_STATE_IDLE;
 173:i2c/i2c_machine.c **** 				NAK();
 174:i2c/i2c_machine.c **** 			} else {
 175:i2c/i2c_machine.c **** 				if (USIDR & 1) {
 176:i2c/i2c_machine.c **** 					/* Transition b */
 177:i2c/i2c_machine.c **** 					i2c_state = I2C_STATE_MASTER_READ;
 178:i2c/i2c_machine.c **** 				} else {
 179:i2c/i2c_machine.c **** 					/* Transition a */
 180:i2c/i2c_machine.c **** 					i2c_offset = 0;
 181:i2c/i2c_machine.c **** 					i2c_state = I2C_STATE_REG_ADDR;
 182:i2c/i2c_machine.c **** 					i2c_update = 1;
 183:i2c/i2c_machine.c **** 				}
 184:i2c/i2c_machine.c **** 				ACK();
 185:i2c/i2c_machine.c **** 			}
 186:i2c/i2c_machine.c **** 			break;
 187:i2c/i2c_machine.c **** 		case I2C_STATE_REG_ADDR:
 188:i2c/i2c_machine.c **** 			if (USIDR > (I2C_N_REG - 1)) {
 189:i2c/i2c_machine.c **** 				/* Transition i */
 190:i2c/i2c_machine.c **** 				i2c_state = I2C_STATE_IDLE;
 191:i2c/i2c_machine.c **** 				NAK();
 192:i2c/i2c_machine.c **** 			} else {
 193:i2c/i2c_machine.c **** 				/* Transition d */
 194:i2c/i2c_machine.c **** 				i2c_offset = USIDR;
 195:i2c/i2c_machine.c **** 				i2c_state = I2C_STATE_MASTER_WRITE;
 196:i2c/i2c_machine.c **** 				ACK();
 197:i2c/i2c_machine.c **** 			}
 198:i2c/i2c_machine.c **** 			break;
 199:i2c/i2c_machine.c **** 		case I2C_STATE_MASTER_READ:
 200:i2c/i2c_machine.c **** 			USIDR = 0;
 201:i2c/i2c_machine.c **** 			/* Listen for master NAK */
 202:i2c/i2c_machine.c **** 			sda_direction = I2C_SDA_DIR_IN;
 203:i2c/i2c_machine.c **** 			break;
 204:i2c/i2c_machine.c **** 		case I2C_STATE_MASTER_WRITE:
 205:i2c/i2c_machine.c **** #if defined(I2C_GLOBAL_WRITE_MASK)
 206:i2c/i2c_machine.c **** 			tmp = I2C_GLOBAL_WRITE_MASK;
 207:i2c/i2c_machine.c **** #else
 208:i2c/i2c_machine.c **** 			tmp = i2c_w_mask[i2c_offset];
 209:i2c/i2c_machine.c **** #endif
 210:i2c/i2c_machine.c **** 			if (tmp) {
 211:i2c/i2c_machine.c **** 				/* Only heed writeable bits */
 212:i2c/i2c_machine.c **** 				i2c_reg[i2c_offset] &= ~tmp;
 184               	.LM8:
 185 0054 E091 0000 		lds r30,i2c_offset
 186 0058 F0E0      		ldi r31,0
 187 005a E050      		subi r30,lo8(-(i2c_reg))
 188 005c F040      		sbci r31,hi8(-(i2c_reg))
 189 005e 8081      		ld r24,Z
 190 0060 1082      		st Z,__zero_reg__
 213:i2c/i2c_machine.c **** 				i2c_reg[i2c_offset] |= USIDR & tmp;
 192               	.LM9:
 193 0062 8FB1      		in r24,0xf
 194 0064 E091 0000 		lds r30,i2c_offset
 195 0068 F0E0      		ldi r31,0
 196 006a E050      		subi r30,lo8(-(i2c_reg))
 197 006c F040      		sbci r31,hi8(-(i2c_reg))
 198 006e 9081      		ld r25,Z
 199 0070 892B      		or r24,r25
 200 0072 8083      		st Z,r24
 214:i2c/i2c_machine.c **** 			}
 215:i2c/i2c_machine.c **** 			i2c_update++;
 202               	.LM10:
 203 0074 8091 0000 		lds r24,i2c_update
 204 0078 8F5F      		subi r24,lo8(-(1))
 205 007a 8093 0000 		sts i2c_update,r24
 216:i2c/i2c_machine.c **** 			i2c_offset++;
 207               	.LM11:
 208 007e 8091 0000 		lds r24,i2c_offset
 209 0082 8F5F      		subi r24,lo8(-(1))
 210 0084 8093 0000 		sts i2c_offset,r24
 211 0088 00C0      		rjmp .L29
 212               	.L9:
 169:i2c/i2c_machine.c **** 			if (tmp && (tmp != I2C_SLAVE_ADDR)) {
 214               	.LM12:
 215 008a 8FB1      		in r24,0xf
 216 008c 8695      		lsr r24
 170:i2c/i2c_machine.c **** 				/* Transition h */
 218               	.LM13:
 219 008e 8F7B      		andi r24,lo8(-65)
 220 0090 01F4      		brne .L28
 175:i2c/i2c_machine.c **** 					/* Transition b */
 222               	.LM14:
 223 0092 789B      		sbis 0xf,0
 224 0094 00C0      		rjmp .L14
 177:i2c/i2c_machine.c **** 				} else {
 226               	.LM15:
 227 0096 82E0      		ldi r24,lo8(2)
 228 0098 00C0      		rjmp .L30
 229               	.L14:
 180:i2c/i2c_machine.c **** 					i2c_state = I2C_STATE_REG_ADDR;
 231               	.LM16:
 232 009a 1092 0000 		sts i2c_offset,__zero_reg__
 181:i2c/i2c_machine.c **** 					i2c_update = 1;
 234               	.LM17:
 235 009e 81E0      		ldi r24,lo8(1)
 236 00a0 8093 0000 		sts i2c_state,r24
 182:i2c/i2c_machine.c **** 				}
 238               	.LM18:
 239 00a4 8093 0000 		sts i2c_update,r24
 240 00a8 00C0      		rjmp .L29
 241               	.L8:
 188:i2c/i2c_machine.c **** 				/* Transition i */
 243               	.LM19:
 244 00aa 8FB1      		in r24,0xf
 245 00ac 8E3F      		cpi r24,lo8(-2)
 246 00ae 00F0      		brlo .L16
 247               	.L28:
 190:i2c/i2c_machine.c **** 				NAK();
 249               	.LM20:
 250 00b0 84E0      		ldi r24,lo8(4)
 251 00b2 8093 0000 		sts i2c_state,r24
 252 00b6 00C0      		rjmp .L25
 253               	.L16:
 194:i2c/i2c_machine.c **** 				i2c_state = I2C_STATE_MASTER_WRITE;
 255               	.LM21:
 256 00b8 8FB1      		in r24,0xf
 257 00ba 8093 0000 		sts i2c_offset,r24
 195:i2c/i2c_machine.c **** 				ACK();
 259               	.LM22:
 260 00be 83E0      		ldi r24,lo8(3)
 261               	.L30:
 262 00c0 8093 0000 		sts i2c_state,r24
 263 00c4 00C0      		rjmp .L29
 264               	.L10:
 200:i2c/i2c_machine.c **** 			/* Listen for master NAK */
 266               	.LM23:
 267 00c6 1FB8      		out 0xf,__zero_reg__
 202:i2c/i2c_machine.c **** 			break;
 269               	.LM24:
 270 00c8 80E0      		ldi r24,0
 203:i2c/i2c_machine.c **** 		case I2C_STATE_MASTER_WRITE:
 272               	.LM25:
 273 00ca 00C0      		rjmp .L13
 274               	.L29:
 217:i2c/i2c_machine.c **** 			ACK();
 276               	.LM26:
 277 00cc 1FB8      		out 0xf,__zero_reg__
 278 00ce 00C0      		rjmp .L27
 279               	.L25:
 218:i2c/i2c_machine.c **** 			break;
 219:i2c/i2c_machine.c **** 		default:
 220:i2c/i2c_machine.c **** 			NAK();
 281               	.LM27:
 282 00d0 80E8      		ldi r24,lo8(-128)
 283 00d2 8FB9      		out 0xf,r24
 284               	.L27:
 165:i2c/i2c_machine.c **** 
 286               	.LM28:
 287 00d4 81E0      		ldi r24,lo8(1)
 288               	.L13:
 221:i2c/i2c_machine.c **** 		}
 222:i2c/i2c_machine.c **** 		/* Counter will overflow again after ACK cycle */
 223:i2c/i2c_machine.c **** 		usisr_tmp |= 14 << USICNT0;
 224:i2c/i2c_machine.c **** 		post_ack = 1;
 290               	.LM29:
 291 00d6 91E0      		ldi r25,lo8(1)
 292 00d8 9093 0000 		sts post_ack.1505,r25
 223:i2c/i2c_machine.c **** 		post_ack = 1;
 294               	.LM30:
 295 00dc 9EED      		ldi r25,lo8(-34)
 296 00de 00C0      		rjmp .L17
 297               	.L6:
 225:i2c/i2c_machine.c **** 	} else {
 226:i2c/i2c_machine.c **** 		/* Work that needs to be done after the ACK cycle */
 227:i2c/i2c_machine.c **** 		sda_direction = I2C_SDA_DIR_IN;
 228:i2c/i2c_machine.c **** 		switch (i2c_state) {
 299               	.LM31:
 300 00e0 8091 0000 		lds r24,i2c_state
 301 00e4 8230      		cpi r24,lo8(2)
 302 00e6 01F4      		brne .L26
 229:i2c/i2c_machine.c **** 		case I2C_STATE_MASTER_READ:
 230:i2c/i2c_machine.c **** 			if (USIDR) {
 304               	.LM32:
 305 00e8 8FB1      		in r24,0xf
 306 00ea 8823      		tst r24
 307 00ec 01F0      		breq .L20
 231:i2c/i2c_machine.c **** 				/* Transition e */
 232:i2c/i2c_machine.c **** 				i2c_offset = 0;
 309               	.LM33:
 310 00ee 1092 0000 		sts i2c_offset,__zero_reg__
 233:i2c/i2c_machine.c **** 				i2c_state = I2C_STATE_IDLE;
 312               	.LM34:
 313 00f2 84E0      		ldi r24,lo8(4)
 314 00f4 8093 0000 		sts i2c_state,r24
 315 00f8 00C0      		rjmp .L26
 316               	.L20:
 234:i2c/i2c_machine.c **** 			} else {
 235:i2c/i2c_machine.c **** 				/* Transition f */
 236:i2c/i2c_machine.c **** 				sda_direction = I2C_SDA_DIR_OUT;
 237:i2c/i2c_machine.c **** 				USIDR = i2c_reg[i2c_offset++];
 318               	.LM35:
 319 00fa E091 0000 		lds r30,i2c_offset
 320 00fe 81E0      		ldi r24,lo8(1)
 321 0100 8E0F      		add r24,r30
 322 0102 8093 0000 		sts i2c_offset,r24
 323 0106 F0E0      		ldi r31,0
 324 0108 E050      		subi r30,lo8(-(i2c_reg))
 325 010a F040      		sbci r31,hi8(-(i2c_reg))
 326 010c 8081      		ld r24,Z
 327 010e 8FB9      		out 0xf,r24
 236:i2c/i2c_machine.c **** 				USIDR = i2c_reg[i2c_offset++];
 329               	.LM36:
 330 0110 81E0      		ldi r24,lo8(1)
 331 0112 00C0      		rjmp .L18
 332               	.L26:
 227:i2c/i2c_machine.c **** 		switch (i2c_state) {
 334               	.LM37:
 335 0114 80E0      		ldi r24,0
 336               	.L18:
 238:i2c/i2c_machine.c **** 			}
 239:i2c/i2c_machine.c **** 			break;
 240:i2c/i2c_machine.c **** 		}
 241:i2c/i2c_machine.c **** 		post_ack = 0;
 338               	.LM38:
 339 0116 1092 0000 		sts post_ack.1505,__zero_reg__
 159:i2c/i2c_machine.c **** 	uint8_t sda_direction;
 341               	.LM39:
 342 011a 90ED      		ldi r25,lo8(-48)
 343               	.L17:
 242:i2c/i2c_machine.c **** 	}
 243:i2c/i2c_machine.c **** 
 244:i2c/i2c_machine.c **** 	if (i2c_offset > (I2C_N_REG - 1))
 345               	.LM40:
 346 011c 2091 0000 		lds r18,i2c_offset
 347 0120 2E3F      		cpi r18,lo8(-2)
 348 0122 00F0      		brlo .L21
 245:i2c/i2c_machine.c **** 		i2c_offset = 0;
 350               	.LM41:
 351 0124 1092 0000 		sts i2c_offset,__zero_reg__
 352               	.L21:
 246:i2c/i2c_machine.c **** 
 247:i2c/i2c_machine.c **** 	/* Set up SDA direction for next operation */
 248:i2c/i2c_machine.c **** 	if (sda_direction == I2C_SDA_DIR_OUT) {
 354               	.LM42:
 355 0128 8130      		cpi r24,lo8(1)
 356 012a 01F4      		brne .L22
 249:i2c/i2c_machine.c **** 		USI_DDR |= (1 << I2C_SDA);
 358               	.LM43:
 359 012c D09A      		sbi 0x1a,0
 360 012e 00C0      		rjmp .L23
 361               	.L22:
 250:i2c/i2c_machine.c **** 	} else {
 251:i2c/i2c_machine.c **** 		USI_DDR &= ~(1 << I2C_SDA);
 363               	.LM44:
 364 0130 D098      		cbi 0x1a,0
 365               	.L23:
 252:i2c/i2c_machine.c **** 	}
 253:i2c/i2c_machine.c **** 
 254:i2c/i2c_machine.c **** 	/* Clear flags and set counter */
 255:i2c/i2c_machine.c **** 	USISR = usisr_tmp;
 367               	.LM45:
 368 0132 9EB9      		out 0xe,r25
 369               	/* epilogue start */
 256:i2c/i2c_machine.c **** }
 371               	.LM46:
 372 0134 FF91      		pop r31
 373 0136 EF91      		pop r30
 374 0138 9F91      		pop r25
 375 013a 8F91      		pop r24
 376 013c 2F91      		pop r18
 377 013e 0F90      		pop r0
 378 0140 0FBE      		out __SREG__,r0
 379 0142 0F90      		pop r0
 380 0144 1F90      		pop r1
 381 0146 1895      		reti
 388               	.Lscope2:
 390               		.stabd	78,0,0
 392               	.global	i2c_init
 394               	i2c_init:
 395               		.stabd	46,0,0
 257:i2c/i2c_machine.c **** 
 258:i2c/i2c_machine.c **** void i2c_init()
 259:i2c/i2c_machine.c **** {
 397               	.LM47:
 398               	.LFBB3:
 399               	/* prologue: function */
 400               	/* frame size = 0 */
 401               	/* stack size = 0 */
 402               	.L__stack_usage = 0
 260:i2c/i2c_machine.c **** 	i2c_state = 0;
 404               	.LM48:
 405 0148 1092 0000 		sts i2c_state,__zero_reg__
 261:i2c/i2c_machine.c **** 	USICR = (1 << USISIE) | (1 << USIOIE) | (3 << USIWM0) | (1 << USICS1);
 407               	.LM49:
 408 014c 88EF      		ldi r24,lo8(-8)
 409 014e 8DB9      		out 0xd,r24
 262:i2c/i2c_machine.c **** 	USI_DDR |= (1 << I2C_SCL);
 411               	.LM50:
 412 0150 D29A      		sbi 0x1a,2
 263:i2c/i2c_machine.c **** 	USI_DDR &= ~(1 << I2C_SDA);
 414               	.LM51:
 415 0152 D098      		cbi 0x1a,0
 264:i2c/i2c_machine.c **** 	USI_PORT |= (1 << I2C_SDA) | (1 << I2C_SCL);
 417               	.LM52:
 418 0154 8BB3      		in r24,0x1b
 419 0156 8560      		ori r24,lo8(5)
 420 0158 8BBB      		out 0x1b,r24
 265:i2c/i2c_machine.c **** 	USISR = 0xF0;
 422               	.LM53:
 423 015a 80EF      		ldi r24,lo8(-16)
 424 015c 8EB9      		out 0xe,r24
 425 015e 0895      		ret
 427               	.Lscope3:
 429               		.stabd	78,0,0
 431               	.global	i2c_transaction_ongoing
 433               	i2c_transaction_ongoing:
 434               		.stabd	46,0,0
 266:i2c/i2c_machine.c **** }
 267:i2c/i2c_machine.c **** 
 268:i2c/i2c_machine.c **** uint8_t i2c_transaction_ongoing()
 269:i2c/i2c_machine.c **** {
 436               	.LM54:
 437               	.LFBB4:
 438               	/* prologue: function */
 439               	/* frame size = 0 */
 440               	/* stack size = 0 */
 441               	.L__stack_usage = 0
 270:i2c/i2c_machine.c **** 	if ((i2c_state != I2C_STATE_IDLE) &&
 443               	.LM55:
 444 0160 8091 0000 		lds r24,i2c_state
 445 0164 8430      		cpi r24,lo8(4)
 446 0166 01F0      		breq .L35
 271:i2c/i2c_machine.c **** 		(i2c_state != I2C_STATE_ADDR_MATCH)) {
 448               	.LM56:
 449 0168 9091 0000 		lds r25,i2c_state
 270:i2c/i2c_machine.c **** 	if ((i2c_state != I2C_STATE_IDLE) &&
 451               	.LM57:
 452 016c 81E0      		ldi r24,lo8(1)
 453 016e 9111      		cpse r25,__zero_reg__
 454 0170 00C0      		rjmp .L33
 455               	.L35:
 272:i2c/i2c_machine.c **** 		return 1;
 273:i2c/i2c_machine.c **** 	} else {
 274:i2c/i2c_machine.c **** 		return 0;
 457               	.LM58:
 458 0172 80E0      		ldi r24,0
 459               	.L33:
 275:i2c/i2c_machine.c **** 	}
 276:i2c/i2c_machine.c **** }
 461               	.LM59:
 462 0174 0895      		ret
 464               	.Lscope4:
 466               		.stabd	78,0,0
 468               	.global	i2c_check_stop
 470               	i2c_check_stop:
 471               		.stabd	46,0,0
 277:i2c/i2c_machine.c **** 
 278:i2c/i2c_machine.c **** uint8_t i2c_check_stop()
 279:i2c/i2c_machine.c **** {
 473               	.LM60:
 474               	.LFBB5:
 475               	/* prologue: function */
 476               	/* frame size = 0 */
 477               	/* stack size = 0 */
 478               	.L__stack_usage = 0
 280:i2c/i2c_machine.c **** 	uint8_t ret = 0;
 281:i2c/i2c_machine.c **** 
 282:i2c/i2c_machine.c **** 	if ((i2c_state == I2C_STATE_MASTER_WRITE) && i2c_update) {
 480               	.LM61:
 481 0176 8091 0000 		lds r24,i2c_state
 482 017a 8330      		cpi r24,lo8(3)
 483 017c 01F4      		brne .L40
 485               	.LM62:
 486 017e 8091 0000 		lds r24,i2c_update
 487 0182 8823      		tst r24
 488 0184 01F0      		breq .L40
 489               	.LBB2:
 283:i2c/i2c_machine.c **** 		cli();
 491               	.LM63:
 492               	/* #APP */
 493               	 ;  283 "i2c/i2c_machine.c" 1
 494 0186 F894      		cli
 495               	 ;  0 "" 2
 284:i2c/i2c_machine.c **** 		uint8_t tmp = USISR;
 285:i2c/i2c_machine.c **** 		if (tmp & (1 << USIPF)) {
 497               	.LM64:
 498               	/* #NOAPP */
 499 0188 759B      		sbis 0xe,5
 500 018a 00C0      		rjmp .L41
 286:i2c/i2c_machine.c **** 			i2c_state = I2C_STATE_IDLE;
 502               	.LM65:
 503 018c 84E0      		ldi r24,lo8(4)
 504 018e 8093 0000 		sts i2c_state,r24
 287:i2c/i2c_machine.c **** 			ret = i2c_update;
 506               	.LM66:
 507 0192 8091 0000 		lds r24,i2c_update
 288:i2c/i2c_machine.c **** 			i2c_update = 0;
 509               	.LM67:
 510 0196 1092 0000 		sts i2c_update,__zero_reg__
 511 019a 00C0      		rjmp .L38
 512               	.L41:
 513               	.LBE2:
 280:i2c/i2c_machine.c **** 
 515               	.LM68:
 516 019c 80E0      		ldi r24,0
 517               	.L38:
 518               	.LBB3:
 289:i2c/i2c_machine.c **** 		}
 290:i2c/i2c_machine.c **** 		sei();
 520               	.LM69:
 521               	/* #APP */
 522               	 ;  290 "i2c/i2c_machine.c" 1
 523 019e 7894      		sei
 524               	 ;  0 "" 2
 525               	/* #NOAPP */
 526 01a0 0895      		ret
 527               	.L40:
 528               	.LBE3:
 280:i2c/i2c_machine.c **** 
 530               	.LM70:
 531 01a2 80E0      		ldi r24,0
 291:i2c/i2c_machine.c **** 	}
 292:i2c/i2c_machine.c **** 	return ret;
 293:i2c/i2c_machine.c **** }
 533               	.LM71:
 534 01a4 0895      		ret
 539               	.Lscope5:
 541               		.stabd	78,0,0
 542               		.local	post_ack.1505
 543               		.comm	post_ack.1505,1,1
 544               	.global	i2c_offset
 545               		.section .bss
 548               	i2c_offset:
 549 0000 00        		.zero	1
 550               	.global	i2c_state
 553               	i2c_state:
 554 0001 00        		.zero	1
 555               	.global	i2c_update
 558               	i2c_update:
 559 0002 00        		.zero	1
 563               		.text
 565               	.Letext0:
 566               		.ident	"GCC: (GNU) 4.9.2"
 567               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:00000000 i2c_machine.c
     /tmp/ccO61SwM.s:2      *ABS*:0000003e __SP_H__
     /tmp/ccO61SwM.s:3      *ABS*:0000003d __SP_L__
     /tmp/ccO61SwM.s:4      *ABS*:0000003f __SREG__
     /tmp/ccO61SwM.s:5      *ABS*:00000000 __tmp_reg__
     /tmp/ccO61SwM.s:6      *ABS*:00000001 __zero_reg__
     /tmp/ccO61SwM.s:105    .text:00000000 __vector_7
     /tmp/ccO61SwM.s:553    .bss:00000001 i2c_state
     /tmp/ccO61SwM.s:148    .text:00000024 __vector_8
                             .bss:00000003 post_ack.1505
     /tmp/ccO61SwM.s:548    .bss:00000000 i2c_offset
     /tmp/ccO61SwM.s:558    .bss:00000002 i2c_update
     /tmp/ccO61SwM.s:394    .text:00000148 i2c_init
     /tmp/ccO61SwM.s:433    .text:00000160 i2c_transaction_ongoing
     /tmp/ccO61SwM.s:470    .text:00000176 i2c_check_stop

UNDEFINED SYMBOLS
i2c_reg
__do_clear_bss
