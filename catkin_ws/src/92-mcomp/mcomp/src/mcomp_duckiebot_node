#!/usr/bin/env python

import rospy
import lcm
import json
import numpy as np
import utils
from time import sleep
from utils import stdout
from threading import Thread
from lcm_types.mcomp_msgs import event_msg, configuration_msg, vgps_location_msg, experiment_log_msg, auto_pilot_msg
from duckietown_msgs.msg import BoolStamped
from log_types import MSG_TYPE

veh = None
verbose = True
lcm_handler = None
e_stop_pub = None
mcomp_configuration = None
last_position = None
last_orientation = None
last_position_time = -1
experiment_log_channel = "MCOMP_LOG"
mcomp_event_channel = "MCOMP_EVENT"
is_stopped = True
is_shutdown = False
release_command_received = False
event_published = False
known_events = []

def log( msg_type, timestamp=None, content={}, n_copies='default' ):
	global verbose
	global lcm_handler, veh, last_position, last_orientation
	if timestamp is None:
		timestamp = utils.now()
	msg = experiment_log_msg()
	msg.timestamp = timestamp
	msg.type = msg_type
	msg.location = last_position.tolist() if last_position is not None else [-999,-999]
	msg.orientation = last_orientation
	msg.vehicle = veh
	msg.content = json.dumps( content )
	# publish log message
	utils.publish( lcm_handler, experiment_log_channel, experiment_log_msg.encode(msg), n_copies )
	if verbose:
		print 'Publishing message `%s` on `%s`' % ( msg_type,  experiment_log_channel )

def stop_vehicle( due_to_dangerous_event=False ):
	global e_stop_pub, is_stopped, mcomp_configuration
	# create message
	msg = BoolStamped()
	msg.header.stamp = rospy.Time.now()
	msg.data = True # acquire control by bypassing auto-pilot
	e_stop_pub.publish(msg)
	# propagate this action as a new event
	if mcomp_configuration['allow_propagation'] and due_to_dangerous_event:
		event_detected( event_at_car_location=True )

	# set the vehicle as stopped
	is_stopped = True
	# log
	log( MSG_TYPE.VEHICLE_STOPPED, utils.now() )

def release_vehicle():
	global e_stop_pub
	# create message
	msg = BoolStamped()
	msg.header.stamp = rospy.Time.now()
	msg.data = False # release control to auto-pilot
	e_stop_pub.publish(msg)
	#
	is_stopped = False
	# log
	log( MSG_TYPE.VEHICLE_RELEASED, utils.now() )

def mcomp_event_msg_handler(channel, data):
	global known_events
	# decode message
	msg = event_msg.decode(data)
	sender_loc = np.asarray( msg.location )
	# drop message if this bot is outside the communication_radius of the sender
	communication_radius = mcomp_configuration['communication_radius']
	# compute distance between the bot and the sender
	distance_from_sender = np.sqrt(
		np.sum(
			np.power(last_position-sender_loc, 2)
		)
	)
	if distance_from_sender < communication_radius:
		known_events.append( event_loc )
		# log
		log( MSG_TYPE.EVENT_RECEIVED, utils.now() )
	else:
		# too far away, message dropped
		pass

def mcomp_configuration_msg_handler(channel, data):
	global mcomp_configuration, is_stopped, event_published, known_events
	# decode configuration message
	msg = configuration_msg.decode(data)
	if len(msg.configuration) == 0:
		mcomp_configuration = None
	else:
		mcomp_configuration = json.loads( msg.configuration )
		mcomp_configuration['event_location'] = np.asarray(
			[ mcomp_configuration['event_location'][0], mcomp_configuration['event_location'][1] ]
		)
	# reset state
	is_stopped = True
	event_published = False
	known_events = []
	# log
	log( MSG_TYPE.CONFIGURATION_RECEIVED, utils.now() )

def mcomp_auto_pilot_msg_handler(channel, data):
	global release_command_received
	# decode configuration message
	msg = auto_pilot_msg.decode(data)
	if msg.enabled:
		release_vehicle()
		release_command_received = True
	else:
		stop_vehicle()
	# log
	log( MSG_TYPE.VEHICLE_RELEASED, utils.now() )

def event_detected( event_at_car_location=False ):
	global event_published, known_events, last_position
	if event_at_car_location:
		event_loc = [ -999, -999 ]
		if last_position is not None:
			event_loc = [ last_position[0], last_position[1] ]
	else:
		event_loc = [ mcomp_configuration['event_location'][0], mcomp_configuration['event_location'][1] ]
	# create event message
	msg = event_msg()
	msg.timestamp = utils.now()
	msg.location = event_loc
	msg.description = "I saw an accident!"
	# send message to other vehicles
	utils.publish( lcm_handler, mcomp_event_channel, event_msg.encode(msg), 2 )
	# log
	log( MSG_TYPE.EVENT_GENERATED, msg.timestamp )
	event_published = True
	known_events.append( np.asarray(event_loc) )

def visual_gps_msg_handler(channel, data):
	global veh, last_position, last_orientation, last_position_time
	msg = vgps_location_msg.decode(data)
	if msg.vehicle == veh: # and msg.timestamp > last_position_time:
		last_position = np.asarray( msg.location )
		last_orientation = msg.theta
		last_position_time = msg.timestamp
		# log
		# if is_configured():
		# 	log(
		# 		MSG_TYPE.GPS,
		# 		utils.now(),
		# 		{ 'posiiton' : last_position.tolist(), 'orientation' : last_orientation }
		# 	)

def car_controller_fcn(args):
	global verbose
	global mcomp_configuration, perception_distance, is_stopped, is_shutdown, event_published, known_events
	global release_command_received
	while not is_shutdown and not rospy.is_shutdown():
		# wait for the experiment to start
		if not is_configured():
			if not is_stopped:
				stop_vehicle()
			sleep(0.05)
			continue

		if is_configured and not release_command_received:
			log( MSG_TYPE.CONFIGURATION_RECEIVED, utils.now() )
			sleep(0.05)
			continue

		# get location of the event
		event_location = mcomp_configuration['event_location']
		perception_distance = mcomp_configuration['perception_distance']

		# compute distance between the bot and the ROI
		distance_from_event = np.sqrt(
			np.sum(
				np.power(last_position-event_location, 2)
			)
		)
		if verbose:
			stdout('Event (verbose)', 'Distance: %.2f meters' % distance_from_event)

		# signal event to other vehicles if close enough
		if distance_from_event < perception_distance and not event_published:
			stop_vehicle( due_to_dangerous_event=True )
			event_detected()

		# if there are knwon events, check if within the reaction radius
		for event_location in known_events:
			distance_from_event = np.sqrt(
				np.sum(
					np.power(last_position-event_location, 2)
				)
			)
			reaction_radius = mcomp_configuration['reaction_radius']
			if distance_from_event < reaction_radius and not is_stopped:
				stop_vehicle( due_to_dangerous_event=True )

		# keep spinning
		sleep(0.1)

def is_configured():
	return mcomp_configuration is not None

if __name__ == '__main__':
	# set up ROS publishing node
	rospy.init_node('mcomp_duckiebot_node')

	# get parameters
	veh = rospy.get_param('~veh')

	# create control override publisher
	e_stop_pub = rospy.Publisher(
		"/%s/joy_mapper_node/joystick_override" % veh,
		BoolStamped,
		queue_size=1
	)

	# initialize LCM
	lcm_handler = lcm.LCM()

	# start listening to other vehicles messages
	mcomp_config_sub = lcm_handler.subscribe("MCOMP_SETUP", mcomp_configuration_msg_handler)
	mcomp_event_sub = lcm_handler.subscribe(mcomp_event_channel, mcomp_event_msg_handler)
	mcomp_autopilot_sub = lcm_handler.subscribe("MCOMP_AUTO_PILOT", mcomp_auto_pilot_msg_handler)
	visual_gps_sub = lcm_handler.subscribe("VISUAL_GPS", visual_gps_msg_handler)

	# start car controller
	car_controller = Thread( target=car_controller_fcn, args=(None,) )
	car_controller.start()

	try:
		while True:
			lcm_handler.handle()
	except KeyboardInterrupt:
		pass
	finally:
		is_shutdown = True
		car_controller.join()
