#!/usr/bin/env python

import rospy
import lcm
import json
import numpy as np
import utils
from time import sleep
from utils import stdout
from threading import Thread
from lcm_types.mcomp_msgs import event_msg, configuration_msg, vgps_location_msg, experiment_log_msg, auto_pilot_msg
from duckietown_msgs.msg import BoolStamped
from log_types import MSG_TYPE

veh = None
verbose = True
lcm_handler = None
e_stop_pub = None
mcomp_configuration = None
last_position = None
last_orientation = None
last_position_time = -1
experiment_log_channel = "MCOMP_LOG"
mcomp_event_channel = "MCOMP_EVENT"
is_stopped = True

def log( msg_type, timestamp=None, content={}, n_copies='default' ):
	global verbose
	global lcm_handler, veh
	if timestamp is None:
		timestamp = utils.now()
	msg = experiment_log_msg()
	msg.timestamp = timestamp
	msg.type = msg_type
	msg.vehicle = veh
	msg.content = json.dumps( content )
	# publish log message
	utils.publish( lcm_handler, experiment_log_channel, experiment_log_msg.encode(msg), n_copies )
	if verbose:
		print 'Publishing message `%s` on `%s`' % ( msg_type,  experiment_log_channel )

def stop_vehicle():
	global e_stop_pub, is_stopped
	# create message
	msg = BoolStamped()
	msg.header.stamp = rospy.Time.now()
	msg.data = True # acquire control by bypassing auto-pilot
	e_stop_pub.publish(msg)
	#
	is_stopped = True
	# log
	log( MSG_TYPE.VEHICLE_STOPPED, utils.now() )

def release_vehicle():
	global e_stop_pub
	# create message
	msg = BoolStamped()
	msg.header.stamp = rospy.Time.now()
	msg.data = False # release control to auto-pilot
	e_stop_pub.publish(msg)
	#
	is_stopped = False
	# log
	log( MSG_TYPE.VEHICLE_RELEASED, utils.now() )

def mcomp_event_msg_handler(channel, data):
	# log
	log( MSG_TYPE.EVENT_RECEIVED, utils.now() )
	# stop vehicle
	stop_vehicle()

def mcomp_configuration_msg_handler(channel, data):
	global mcomp_configuration
	# decode configuration message
	msg = configuration_msg.decode(data)
	if len(msg.configuration) == 0:
		mcomp_configuration = None
	else:
		mcomp_configuration = json.loads( msg.configuration )
		mcomp_configuration['event_location'] = np.asarray(
			[ mcomp_configuration['event_location'][0], mcomp_configuration['event_location'][1] ]
		)
	# log
	log( MSG_TYPE.CONFIGURATION_RECEIVED, utils.now() )

def mcomp_auto_pilot_msg_handler(channel, data):
	# decode configuration message
	msg = auto_pilot_msg.decode(data)
	if msg.enabled:
		release_vehicle()
	else:
		stop_vehicle()
	# log
	log( MSG_TYPE.VEHICLE_RELEASED, utils.now() )

def event_detected():
	# create event message
	msg = event_msg()
	msg.timestamp = utils.now()
	msg.position = [ mcomp_configuration['event_location'][0], mcomp_configuration['event_location'][1] ]
	msg.description = "I saw an accident!"
	# send message to other vehicles
	utils.publish( lcm_handler, mcomp_event_channel, event_msg.encode(msg), 2 )
	# log
	log( MSG_TYPE.EVENT_GENERATED, msg.timestamp )

def visual_gps_msg_handler(channel, data):
	global veh, last_position, last_orientation, last_position_time
	msg = vgps_location_msg.decode(data)
	if msg.vehicle == veh: # and msg.timestamp > last_position_time:
		last_position = np.asarray( msg.location )
		last_orientation = msg.theta
		last_position_time = msg.timestamp
		# log
		# if is_configured():
		# 	log(
		# 		MSG_TYPE.GPS,
		# 		utils.now(),
		# 		{ 'posiiton' : last_position.tolist(), 'orientation' : last_orientation }
		# 	)

def car_controller_fcn(args):
	global verbose
	global mcomp_configuration, perception_distance, is_stopped
	while not rospy.is_shutdown():
		# wait for the experiment to start
		if not is_configured():
			if not is_stopped:
				stop_vehicle()
			sleep(0.05)
			continue
		# get location of the event
		event_location = mcomp_configuration['event_location']
		perception_distance = mcomp_configuration['perception_distance']

		# compute distance between the bot and the ROI
		distance_from_event = np.sqrt(
			np.sum(
				np.power(last_position-event_location, 2)
			)
		)
		if verbose:
			stdout('Event (verbose)', 'Distance: %.2f meters' % distance_from_event)

		# signal event to other vehicles if close enough
		if distance_from_event < perception_distance:
			stop_vehicle()
			event_detected()

		# keep spinning
		sleep(0.1)

def is_configured():
	return mcomp_configuration is not None

if __name__ == '__main__':
	# set up ROS publishing node
	rospy.init_node('mcomp_duckiebot_node')

	# get parameters
	veh = rospy.get_param('~veh')

	# create control override publisher
	e_stop_pub = rospy.Publisher(
		"/%s/joy_mapper_node/joystick_override" % veh,
		BoolStamped,
		queue_size=1
	)

	# initialize LCM
	lcm_handler = lcm.LCM()

	# start listening to other vehicles messages
	mcomp_config_sub = lcm_handler.subscribe("MCOMP_SETUP", mcomp_configuration_msg_handler)
	mcomp_event_sub = lcm_handler.subscribe(mcomp_event_channel, mcomp_event_msg_handler)
	mcomp_autopilot_sub = lcm_handler.subscribe("MCOMP_AUTO_PILOT", mcomp_auto_pilot_msg_handler)
	visual_gps_sub = lcm_handler.subscribe("VISUAL_GPS", visual_gps_msg_handler)

	# start car controller
	car_controller = Thread( target=car_controller_fcn, args=(None,) )
	car_controller.start()

	try:
		while True:
			lcm_handler.handle()
	except KeyboardInterrupt:
		pass
	finally:
		car_controller.join()
